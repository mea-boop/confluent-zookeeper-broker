---
# ==============================================================================
# Configure Kafka Broker
#
# server.properties strategy: UPSERT (append new, update existing)
#   - Template renders to /tmp staging file (no secrets - uses ${securepass:...})
#   - Each key=value line is upserted into the live server.properties
#   - Live file is never truncated - existing/manual properties preserved
#   - New properties added to server.properties.j2 are appended automatically
# ==============================================================================

# ------------------------------------------------------------------
# Load variables explicitly - guarantees they are available even if
# group_vars auto-load did not fire (AAP group name mismatch etc.)
# ------------------------------------------------------------------
- name: "CONFIGURE | Load group_vars/all.yml"
  ansible.builtin.include_vars:
    file: "{{ playbook_dir }}/../group_vars/all.yml"

- name: "CONFIGURE | Load and decrypt vault_secrets.yml"
  ansible.builtin.include_vars:
    file: "{{ playbook_dir }}/../group_vars/vault_secrets.yml"
  no_log: true   # suppress only this task - vault file contains encrypted blobs

# ------------------------------------------------------------------
# Set plain-name variables from vault so templates can reference them directly
# Note: confluent_license is NOT from vault - it is a plain var in all.yml
# ------------------------------------------------------------------
- name: "CONFIGURE | Map vault_ variables to plain names"
  ansible.builtin.set_fact:
    kafka_admin_password:    "{{ vault_kafka_admin_password }}"
    ldap_bind_password:      "{{ vault_ldap_bind_password }}"
    ssl_truststore_password: "{{ vault_ssl_truststore_password }}"
    ssl_keystore_password:   "{{ vault_ssl_keystore_password }}"
    ssl_key_password:              "{{ vault_ssl_key_password }}"
    confluent_security_master_key: "{{ vault_confluent_security_master_key }}"
  no_log: true   # suppress only this task - values are plaintext secrets

# ------------------------------------------------------------------
# Resolve broker_id from the FQDN→ID map
# ------------------------------------------------------------------
- name: "CONFIGURE | Resolve broker_id for {{ inventory_hostname }}"
  ansible.builtin.set_fact:
    broker_id: "{{ broker_id_map[inventory_hostname] }}"
    cacheable: true

- name: "CONFIGURE | Display broker identity"
  ansible.builtin.debug:
    msg: "Broker ID {{ broker_id }} → {{ ansible_fqdn }}"

# ------------------------------------------------------------------
# Pre-flight checks
# ------------------------------------------------------------------
- name: "CONFIGURE | Verify all broker FQDNs are defined"
  ansible.builtin.assert:
    that:
      - hostvars[item]['ansible_fqdn'] is defined
      - hostvars[item]['ansible_fqdn'] != ''
    fail_msg: "FQDN not found for {{ item }}"
  loop: "{{ groups['all'] }}"
  run_once: true

- name: "CONFIGURE | Verify all broker_id_map entries exist"
  ansible.builtin.assert:
    that:
      - broker_id_map[item] is defined
    fail_msg: "broker_id_map entry missing for: {{ item }}"
  loop: "{{ groups['all'] }}"
  run_once: true

# ------------------------------------------------------------------
# Ensure config directory exists
# ------------------------------------------------------------------
- name: "CONFIGURE | Create broker config directory"
  ansible.builtin.file:
    path: "{{ broker_config_dir }}"
    state: directory
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: "0755"

# ==================================================================
# UPSERT STRATEGY FOR server.properties
#
# Step 1: Render template → /tmp/server.properties.staged
#         NO no_log here - staging file uses ${securepass:...}
#         placeholders, not plaintext secrets. Showing errors is
#         essential for debugging Jinja2 template problems.
#
# Step 2: Slurp staged file, filter to key=value lines only
#
# Step 3: For each line, extract the key as everything before the
#         FIRST '=' only (handles values that contain '=' signs,
#         e.g. jaas.config lines with password=...)
#
# Step 4: lineinfile upserts each key into the live file:
#         - key exists → value updated in-place
#         - key missing → line appended at end of file
#
# Step 5: Cleanup staging file
# ==================================================================

- name: "CONFIGURE | Render server.properties to staging file /tmp/server.properties.staged"
  ansible.builtin.template:
    src: server.properties.j2
    dest: /tmp/server.properties.staged
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: "0640"
  no_log: true
  # no_log: staging file now contains config.providers.securepass.param.master.encryption.key
  # in plaintext. If the template fails, temporarily set no_log: false to debug,
  # then set it back to true before committing.

- name: "CONFIGURE | Ensure live server.properties exists"
  ansible.builtin.file:
    path: "{{ broker_config_dir }}/server.properties"
    state: touch
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: "0640"
    modification_time: preserve
    access_time: preserve

- name: "CONFIGURE | Slurp staged server.properties"
  ansible.builtin.slurp:
    src: /tmp/server.properties.staged
  register: staged_raw

- name: "CONFIGURE | Parse key=value lines from staged file"
  ansible.builtin.set_fact:
    staged_props: >-
      {{
        (staged_raw.content | b64decode).splitlines()
        | select('match', '^[A-Za-z][A-Za-z0-9._-]+=')
        | list
      }}

# Build a list of dicts: [{key: ..., line: ...}, ...]
# Key = everything before the FIRST '=' only.
# This correctly handles lines like:
#   sasl.jaas.config=Module required username="x" password=y;
# where a naive split('=')[0] on the whole line would be wrong.
- name: "CONFIGURE | Extract property keys from staged lines"
  ansible.builtin.set_fact:
    staged_kv: >-
      {{
        staged_props | map('regex_replace', '^([^=]+)=.*$', '\1') | list
      }}

- name: "CONFIGURE | Upsert each property into live server.properties"
  ansible.builtin.lineinfile:
    path: "{{ broker_config_dir }}/server.properties"
    regexp: "^{{ staged_kv[idx] | regex_escape }}="
    line: "{{ item }}"
    state: present
    create: true
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: "0640"
    backup: false
  loop: "{{ staged_props }}"
  loop_control:
    index_var: idx
    label: "{{ staged_kv[idx] }}"
  notify: restart confluent-kafka
  no_log: true
  # no_log: loop iterates the master.encryption.key line in plaintext

- name: "CONFIGURE | Remove staging file"
  ansible.builtin.file:
    path: /tmp/server.properties.staged
    state: absent

# ------------------------------------------------------------------
# Deploy remaining config files (full replace - no secrets in these)
# ------------------------------------------------------------------
- name: "CONFIGURE | Deploy log4j.properties"
  ansible.builtin.template:
    src: log4j.properties.j2
    dest: "{{ broker_config_dir }}/log4j.properties"
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: "0644"
  notify: restart confluent-kafka

- name: "CONFIGURE | Deploy broker-env.sh"
  ansible.builtin.template:
    src: broker-env.sh.j2
    dest: "{{ broker_install_dir }}/bin/broker-env.sh"
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: "0755"
  notify: restart confluent-kafka
