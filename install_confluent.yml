---
# ==============================================================================
# install_confluent.yml
#
# Builds /etc/hosts entries and cluster connection strings dynamically from
# AAP inventory groups (broker_nodes, zookeeper_nodes) — no hardcoded IPs.
# Downloads all Confluent artifacts from JFrog and installs the platform.
#
# AAP inventory groups required:
#   broker_nodes      — Kafka broker hosts
#   zookeeper_nodes   — ZooKeeper hosts
#
# For each host Ansible resolves:
#   ansible_host  → IP written into /etc/hosts
#   inventory_hostname / ansible_fqdn → FQDN used in connect strings
# ==============================================================================

# ---------- Build /etc/hosts from AAP inventory groups ----------

- name: "INSTALL | Add broker_nodes entries to /etc/hosts"
  ansible.builtin.lineinfile:
    path: /etc/hosts
    line: "{{ hostvars[item]['ansible_host'] }} {{ hostvars[item]['ansible_fqdn'] }}"
    regexp: "{{ hostvars[item]['ansible_fqdn'] | regex_escape }}"
    state: present
  loop: "{{ groups['broker_nodes'] }}"
  loop_control:
    label: "{{ item }}"
  run_once: false   # runs on every broker so each host gets all peers

- name: "INSTALL | Add zookeeper_nodes entries to /etc/hosts"
  ansible.builtin.lineinfile:
    path: /etc/hosts
    line: "{{ hostvars[item]['ansible_host'] }} {{ hostvars[item]['ansible_fqdn'] }}"
    regexp: "{{ hostvars[item]['ansible_fqdn'] | regex_escape }}"
    state: present
  loop: "{{ groups['zookeeper_nodes'] }}"
  loop_control:
    label: "{{ item }}"

# ---------- Build bootstrap + ZooKeeper connect strings from inventory ----------

- name: "INSTALL | Build bootstrap servers string from broker_nodes group"
  ansible.builtin.set_fact:
    bstring: >-
      {{
        groups['broker_nodes']
        | map('extract', hostvars, 'ansible_fqdn')
        | map('regex_replace', '$', ':' ~ kafka_sasl_ssl_port | string)
        | join(',')
      }}
    cacheable: true

- name: "INSTALL | Build ZooKeeper connect string from zookeeper_nodes group"
  ansible.builtin.set_fact:
    zookeeper_connect_dynamic: >-
      {{
        groups['zookeeper_nodes']
        | map('extract', hostvars, 'ansible_fqdn')
        | map('regex_replace', '$', ':2181')
        | join(',')
      }}
    cacheable: true

- name: "INSTALL | Display resolved connection strings"
  ansible.builtin.debug:
    msg:
      - "Bootstrap servers : {{ bstring }}"
      - "ZooKeeper connect : {{ zookeeper_connect_dynamic }}"
  run_once: true

# ---------- Download SSL certificates from JFrog ----------

- name: "INSTALL | Download truststore.jks from JFrog"
  ansible.builtin.get_url:
    url: "{{ jfrog_base_url }}/{{ jfrog_repo }}/certificates/truststore.jks"
    dest: "{{ ssl_dir }}/truststore.jks"
    url_username: "{{ jfrog_user }}"
    url_password: "{{ jfrog_password }}"
    force_basic_auth: true
    mode: '0644'
    validate_certs: true
  retries: "{{ download_retries }}"
  delay: "{{ download_delay }}"
  register: dl_truststore
  until: dl_truststore is succeeded
  no_log: true

- name: "INSTALL | Download server keystore ({{ ssl_keystore_filename }}) from JFrog"
  ansible.builtin.get_url:
    url: "{{ jfrog_base_url }}/{{ jfrog_repo }}/certificates/{{ ssl_keystore_filename }}"
    dest: "{{ ssl_dir }}/{{ ssl_keystore_filename }}"
    url_username: "{{ jfrog_user }}"
    url_password: "{{ jfrog_password }}"
    force_basic_auth: true
    mode: '0644'
    validate_certs: true
  retries: "{{ download_retries }}"
  delay: "{{ download_delay }}"
  register: dl_cert
  until: dl_cert is succeeded
  no_log: true

- name: "INSTALL | Download chain root certificate from JFrog"
  ansible.builtin.get_url:
    url: "{{ jfrog_base_url }}/{{ jfrog_repo }}/certificates/chainrootcertificate.cer"
    dest: /etc/chainrootcertificate.cer
    url_username: "{{ jfrog_user }}"
    url_password: "{{ jfrog_password }}"
    force_basic_auth: true
    mode: '0644'
    validate_certs: true
  retries: "{{ download_retries }}"
  delay: "{{ download_delay }}"
  register: dl_chain
  until: dl_chain is succeeded
  no_log: true

- name: "INSTALL | Download MDS keypair PEM from JFrog"
  ansible.builtin.get_url:
    url: "{{ jfrog_base_url }}/{{ jfrog_repo }}/certificates/certs/mdskeypair.pem"
    dest: "{{ mds_keypair_path }}"
    url_username: "{{ jfrog_user }}"
    url_password: "{{ jfrog_password }}"
    force_basic_auth: true
    mode: '0455'
    validate_certs: true
  retries: "{{ download_retries }}"
  delay: "{{ download_delay }}"
  register: dl_mdskey
  until: dl_mdskey is succeeded
  no_log: true

- name: "INSTALL | Download MDS public PEM from JFrog"
  ansible.builtin.get_url:
    url: "{{ jfrog_base_url }}/{{ jfrog_repo }}/certificates/certs/mdspublic.pem"
    dest: "{{ mds_public_key_path }}"
    url_username: "{{ jfrog_user }}"
    url_password: "{{ jfrog_password }}"
    force_basic_auth: true
    mode: '0455'
    validate_certs: true
  retries: "{{ download_retries }}"
  delay: "{{ download_delay }}"
  register: dl_mdspub
  until: dl_mdspub is succeeded
  no_log: true

- name: "INSTALL | Set {{ ssl_dir }} ownership to {{ broker_user }}"
  ansible.builtin.file:
    path: "{{ ssl_dir }}"
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    recurse: true

# ---------- Download Confluent CLI from JFrog ----------

- name: "INSTALL | Download Confluent CLI from JFrog"
  ansible.builtin.get_url:
    url: "{{ jfrog_base_url }}/{{ jfrog_repo }}/confluent/cli/confluent"
    dest: /tmp/confluent
    url_username: "{{ jfrog_user }}"
    url_password: "{{ jfrog_password }}"
    force_basic_auth: true
    mode: '0755'
    validate_certs: true
  retries: "{{ download_retries }}"
  delay: "{{ download_delay }}"
  register: dl_cli
  until: dl_cli is succeeded
  no_log: true

- name: "INSTALL | Set Confluent CLI ownership"
  ansible.builtin.file:
    path: /tmp/confluent
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"

# ---------- Download and install Confluent Platform ----------

- name: "INSTALL | Download Confluent Platform tarball from JFrog"
  ansible.builtin.get_url:
    url: "{{ jfrog_base_url }}/{{ jfrog_repo }}/confluent/{{ confluent_version }}/{{ confluent_version }}.tar"
    dest: "{{ confluent_package_path }}"
    url_username: "{{ jfrog_user }}"
    url_password: "{{ jfrog_password }}"
    force_basic_auth: true
    mode: '0644'
    validate_certs: true
  retries: "{{ download_retries }}"
  delay: "{{ download_delay }}"
  register: dl_confluent
  until: dl_confluent is succeeded
  no_log: true

- name: "INSTALL | Create install directory {{ broker_install_dir }}"
  ansible.builtin.file:
    path: "{{ broker_install_dir }}"
    state: directory
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: "0755"

- name: "INSTALL | Extract Confluent Platform tarball to /tmp"
  ansible.builtin.unarchive:
    src: "{{ confluent_package_path }}"
    dest: /tmp/
    remote_src: true
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"

- name: "INSTALL | Find extracted Confluent directory under /tmp"
  ansible.builtin.find:
    paths: /tmp
    patterns: "confluent*"
    file_type: directory
    recurse: false
  register: confluent_dirs

- name: "INSTALL | Fail if no confluent* directory found in /tmp"
  ansible.builtin.fail:
    msg: >-
      No confluent* directory found in /tmp after extraction.
      Check that {{ confluent_package_path }} is a valid Confluent Platform tar.
  when: confluent_dirs.matched == 0

- name: "INSTALL | Set extracted directory fact"
  ansible.builtin.set_fact:
    extracted_dir: "{{ (confluent_dirs.files | sort(attribute='path') | last)['path'] }}"
  when: confluent_dirs.matched > 0

- name: "INSTALL | Copy Confluent files to {{ broker_install_dir }}"
  ansible.builtin.copy:
    src: "{{ extracted_dir }}/"
    dest: "{{ broker_install_dir }}/"
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    mode: preserve
    remote_src: true

- name: "INSTALL | Set ownership on {{ broker_install_dir }}"
  ansible.builtin.file:
    path: "{{ broker_install_dir }}"
    state: directory
    owner: "{{ broker_user }}"
    group: "{{ broker_group }}"
    recurse: true

- name: "INSTALL | Verify kafka-server-start binary exists"
  ansible.builtin.stat:
    path: "{{ broker_install_dir }}/bin/kafka-server-start"
  register: kafka_binary

- name: "INSTALL | Fail if kafka-server-start binary not found"
  ansible.builtin.fail:
    msg: >-
      kafka-server-start not found in {{ broker_install_dir }}/bin.
      Verify the tar contains a valid Confluent Platform distribution.
  when: not kafka_binary.stat.exists

- name: "INSTALL | Confirm installation"
  ansible.builtin.debug:
    msg: "Confluent installed at {{ broker_install_dir }} (binary verified)"
